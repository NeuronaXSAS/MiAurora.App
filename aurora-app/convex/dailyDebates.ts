import { v } from "convex/values";
import { query, mutation } from "./_generated/server";

// Categories for daily debates
const DEBATE_CATEGORIES = [
  "safety",
  "career", 
  "health",
  "rights",
  "tech",
  "world",
] as const;

/**
 * Get today's 6 debates
 */
export const getTodayDebates = query({
  args: {},
  handler: async (ctx) => {
    const today = new Date().toISOString().split("T")[0];
    const debates = await ctx.db
      .query("dailyDebates")
      .withIndex("by_date", (q) => q.eq("date", today))
      .filter((q) => q.eq(q.field("isActive"), true))
      .collect();
    
    return debates.sort((a, b) => a.slot - b.slot);
  },
});

/**
 * Get debates by specific date
 */
export const getDebatesByDate = query({
  args: { date: v.string() },
  handler: async (ctx, args) => {
    const debates = await ctx.db
      .query("dailyDebates")
      .withIndex("by_date", (q) => q.eq("date", args.date))
      .collect();
    
    return debates.sort((a, b) => a.slot - b.slot);
  },
});

/**
 * Create a debate (admin only)
 */
export const createDebate = mutation({
  args: {
    date: v.string(),
    slot: v.number(),
    category: v.union(
      v.literal("safety"),
      v.literal("career"),
      v.literal("health"),
      v.literal("rights"),
      v.literal("tech"),
      v.literal("world")
    ),
    title: v.string(),
    summary: v.string(),
    sourceUrl: v.string(),
    sourceName: v.string(),
    imageUrl: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // Check if slot already exists for this date
    const existing = await ctx.db
      .query("dailyDebates")
      .withIndex("by_date_slot", (q) => 
        q.eq("date", args.date).eq("slot", args.slot)
      )
      .first();
    
    if (existing) {
      // Update existing debate
      await ctx.db.patch(existing._id, {
        category: args.category,
        title: args.title,
        summary: args.summary,
        sourceUrl: args.sourceUrl,
        sourceName: args.sourceName,
        imageUrl: args.imageUrl,
        isAutoGenerated: false,
      });
      return existing._id;
    }
    
    // Create new debate
    return await ctx.db.insert("dailyDebates", {
      date: args.date,
      slot: args.slot,
      category: args.category,
      title: args.title,
      summary: args.summary,
      sourceUrl: args.sourceUrl,
      sourceName: args.sourceName,
      imageUrl: args.imageUrl,
      agreeCount: 0,
      disagreeCount: 0,
      neutralCount: 0,
      commentCount: 0,
      isAutoGenerated: false,
      isActive: true,
    });
  },
});


/**
 * Vote on a debate
 */
export const voteOnDebate = mutation({
  args: {
    debateId: v.id("dailyDebates"),
    vote: v.union(v.literal("agree"), v.literal("disagree"), v.literal("neutral")),
    // Anonymous voting
    sessionHash: v.optional(v.string()),
    anonymousId: v.optional(v.id("anonymousDebaters")),
    // Member voting
    memberId: v.optional(v.id("users")),
  },
  handler: async (ctx, args) => {
    const debate = await ctx.db.get(args.debateId);
    if (!debate) throw new Error("Debate not found");

    const voterType = args.memberId ? "member" : "anonymous";
    
    // Check for existing vote
    let existingVote = null;
    if (args.memberId) {
      existingVote = await ctx.db
        .query("debateVotes")
        .withIndex("by_member_debate", (q) => 
          q.eq("memberId", args.memberId).eq("debateId", args.debateId)
        )
        .first();
    } else if (args.anonymousId) {
      existingVote = await ctx.db
        .query("debateVotes")
        .withIndex("by_anonymous_debate", (q) => 
          q.eq("anonymousId", args.anonymousId).eq("debateId", args.debateId)
        )
        .first();
    }

    // Update vote counts
    const updates: Record<string, number> = {};
    
    if (existingVote) {
      // Remove old vote count
      if (existingVote.vote === "agree") updates.agreeCount = debate.agreeCount - 1;
      else if (existingVote.vote === "disagree") updates.disagreeCount = debate.disagreeCount - 1;
      else updates.neutralCount = debate.neutralCount - 1;
      
      // Update existing vote
      await ctx.db.patch(existingVote._id, { vote: args.vote, timestamp: Date.now() });
    } else {
      // Create new vote
      await ctx.db.insert("debateVotes", {
        debateId: args.debateId,
        voterType,
        anonymousId: args.anonymousId,
        memberId: args.memberId,
        vote: args.vote,
        timestamp: Date.now(),
      });
    }

    // Add new vote count
    if (args.vote === "agree") updates.agreeCount = (updates.agreeCount ?? debate.agreeCount) + 1;
    else if (args.vote === "disagree") updates.disagreeCount = (updates.disagreeCount ?? debate.disagreeCount) + 1;
    else updates.neutralCount = (updates.neutralCount ?? debate.neutralCount) + 1;

    await ctx.db.patch(args.debateId, updates);

    // Only award credits to REGISTERED users (not anonymous)
    // Anonymous users get gamified messages but no real credits
    if (args.memberId && !existingVote) {
      const user = await ctx.db.get(args.memberId);
      if (user) {
        await ctx.db.patch(args.memberId, {
          credits: (user.credits || 0) + 2,
        });
        return { success: true, creditsAwarded: 2, isRegistered: true };
      }
    }

    // For anonymous users - return gamified response without storing credits
    return { 
      success: true, 
      creditsAwarded: 0, 
      isRegistered: false,
      message: "Your voice matters! Join Aurora App to earn credits and save your history."
    };
  },
});

/**
 * Add a comment to a debate
 */
export const addComment = mutation({
  args: {
    debateId: v.id("dailyDebates"),
    content: v.string(),
    parentId: v.optional(v.id("debateComments")),
    // Anonymous
    anonymousId: v.optional(v.id("anonymousDebaters")),
    // Member
    memberId: v.optional(v.id("users")),
  },
  handler: async (ctx, args) => {
    const debate = await ctx.db.get(args.debateId);
    if (!debate) throw new Error("Debate not found");

    const authorType = args.memberId ? "member" : "anonymous";

    const commentId = await ctx.db.insert("debateComments", {
      debateId: args.debateId,
      authorType,
      anonymousId: args.anonymousId,
      memberId: args.memberId,
      content: args.content,
      upvotes: 0,
      downvotes: 0,
      replyCount: 0,
      parentId: args.parentId,
      isHidden: false,
    });

    // Update debate comment count
    await ctx.db.patch(args.debateId, {
      commentCount: debate.commentCount + 1,
    });

    // Update parent reply count if this is a reply
    if (args.parentId) {
      const parent = await ctx.db.get(args.parentId);
      if (parent) {
        await ctx.db.patch(args.parentId, {
          replyCount: parent.replyCount + 1,
        });
      }
    }

    // Only award credits to REGISTERED users (not anonymous)
    // Anonymous users get gamified messages but no real credits
    if (args.memberId) {
      const user = await ctx.db.get(args.memberId);
      if (user) {
        await ctx.db.patch(args.memberId, {
          credits: (user.credits || 0) + 3,
        });
        return { commentId, creditsAwarded: 3, isRegistered: true };
      }
    }

    // For anonymous users - return gamified response
    return { 
      commentId, 
      creditsAwarded: 0, 
      isRegistered: false,
      message: "Great insight! Join Aurora App to earn 3 credits for every comment."
    };
  },
});

/**
 * Get comments for a debate
 */
export const getDebateComments = query({
  args: { debateId: v.id("dailyDebates") },
  handler: async (ctx, args) => {
    const comments = await ctx.db
      .query("debateComments")
      .withIndex("by_debate", (q) => q.eq("debateId", args.debateId))
      .filter((q) => q.eq(q.field("isHidden"), false))
      .collect();

    // Enrich with author info
    const enrichedComments = await Promise.all(
      comments.map(async (comment) => {
        let authorName = "Anonymous";
        let authorFlag = "ðŸŒ";
        let authorBadge = null;

        if (comment.authorType === "member" && comment.memberId) {
          const member = await ctx.db.get(comment.memberId);
          if (member) {
            authorName = member.name;
            authorFlag = ""; // Members don't show flag
            authorBadge = member.isPremium ? "premium" : null;
          }
        } else if (comment.anonymousId) {
          const anon = await ctx.db.get(comment.anonymousId);
          if (anon) {
            authorName = anon.pseudonym;
            authorFlag = anon.countryFlag;
          }
        }

        return {
          ...comment,
          authorName,
          authorFlag,
          authorBadge,
        };
      })
    );

    return enrichedComments;
  },
});

/**
 * Get vote distribution for a debate
 */
export const getVoteDistribution = query({
  args: { debateId: v.id("dailyDebates") },
  handler: async (ctx, args) => {
    const debate = await ctx.db.get(args.debateId);
    if (!debate) return null;

    const total = debate.agreeCount + debate.disagreeCount + debate.neutralCount;
    
    return {
      agree: debate.agreeCount,
      disagree: debate.disagreeCount,
      neutral: debate.neutralCount,
      total,
      agreePercent: total > 0 ? Math.round((debate.agreeCount / total) * 100) : 0,
      disagreePercent: total > 0 ? Math.round((debate.disagreeCount / total) * 100) : 0,
      neutralPercent: total > 0 ? Math.round((debate.neutralCount / total) * 100) : 0,
    };
  },
});


/**
 * Check if debates exist for a given date
 */
export const hasDebatesForDate = query({
  args: { date: v.string() },
  handler: async (ctx, args) => {
    const debates = await ctx.db
      .query("dailyDebates")
      .withIndex("by_date", (q) => q.eq("date", args.date))
      .collect();
    
    return {
      hasDebates: debates.length > 0,
      count: debates.length,
      isComplete: debates.length >= 6,
    };
  },
});

/**
 * Auto-generate debates for today if none exist
 * This can be called by a scheduled function or manually by admin
 * Uses predefined topics when Search API is not available
 */
export const autoGenerateDebates = mutation({
  args: {
    date: v.optional(v.string()),
    forceRegenerate: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const targetDate = args.date || new Date().toISOString().split("T")[0];
    
    // Check if debates already exist
    const existing = await ctx.db
      .query("dailyDebates")
      .withIndex("by_date", (q) => q.eq("date", targetDate))
      .collect();
    
    if (existing.length >= 6 && !args.forceRegenerate) {
      return { success: false, message: "Debates already exist for this date", count: existing.length };
    }

    // If force regenerate, deactivate existing debates
    if (args.forceRegenerate && existing.length > 0) {
      for (const debate of existing) {
        await ctx.db.patch(debate._id, { isActive: false });
      }
    }

    // Predefined debate topics by category (rotates based on day of year)
    const debateTopics = {
      safety: [
        { title: "Should women share their location with trusted contacts at all times?", summary: "Discussing the balance between safety and privacy in location sharing." },
        { title: "Are ride-sharing apps doing enough to protect women passengers?",  summary: "Evaluating safety measures in transportation services." },
        { title: "Should self-defense training be mandatory in schools for girls?", summary: "Debating the role of education in women's safety." },
        { title: "Is walking alone at night ever truly safe for women?", summary: "Examining urban safety and women's freedom of movement." },
        { title: "Should there be women-only public transportation options?", summary: "Discussing gender-segregated transit solutions." },
      ],
      career: [
        { title: "Should companies be required to publish gender pay gap data?", summary: "Transparency in workplace compensation practices." },
        { title: "Is remote work better for women's career advancement?", summary: "Examining the impact of flexible work on women's careers." },
        { title: "Should there be quotas for women in leadership positions?", summary: "Debating affirmative action in corporate leadership." },
        { title: "Are women penalized for negotiating salaries?", summary: "Discussing gender dynamics in salary negotiations." },
        { title: "Should parental leave be equal for all genders?", summary: "Examining the impact of leave policies on women's careers." },
      ],
      health: [
        { title: "Is women's health research adequately funded?", summary: "Discussing gender disparities in medical research." },
        { title: "Should menstrual products be free for all women?", summary: "Debating period poverty and access to hygiene products." },
        { title: "Are women's pain symptoms taken seriously by doctors?", summary: "Examining gender bias in healthcare." },
        { title: "Should mental health days be a workplace right?", summary: "Discussing mental health support for working women." },
        { title: "Is the beauty industry harmful to women's self-image?", summary: "Examining beauty standards and mental health." },
      ],
      rights: [
        { title: "Should online harassment of women carry stricter penalties?", summary: "Discussing legal protections against cyber abuse." },
        { title: "Are current domestic violence laws adequate?", summary: "Examining legal protections for abuse survivors." },
        { title: "Should there be a global standard for women's rights?", summary: "Debating international women's rights frameworks." },
        { title: "Is the gender gap in STEM fields closing fast enough?", summary: "Discussing progress in gender equality in technology." },
        { title: "Should childcare be a universal right?", summary: "Examining childcare policies and women's economic participation." },
      ],
      tech: [
        { title: "Is AI perpetuating gender bias in hiring?", summary: "Examining algorithmic bias in recruitment technology." },
        { title: "Should social media platforms do more to protect women?", summary: "Discussing platform responsibility for user safety." },
        { title: "Are women adequately represented in tech leadership?", summary: "Examining gender diversity in technology companies." },
        { title: "Is the metaverse safe for women?", summary: "Discussing safety concerns in virtual reality spaces." },
        { title: "Should there be more women-focused tech products?", summary: "Examining the gender gap in product design." },
      ],
      world: [
        { title: "Is climate change affecting women disproportionately?", summary: "Examining the gendered impact of environmental change." },
        { title: "Should more countries have women leaders?", summary: "Discussing gender representation in global politics." },
        { title: "Are women's voices heard in peace negotiations?", summary: "Examining women's role in conflict resolution." },
        { title: "Is education the key to women's empowerment globally?", summary: "Discussing the impact of education on women's rights." },
        { title: "Should there be a global minimum wage for women?", summary: "Examining economic policies for gender equality." },
      ],
    };

    // Get day of year to rotate topics
    const dayOfYear = Math.floor((Date.now() - new Date(new Date().getFullYear(), 0, 0).getTime()) / 86400000);
    
    const categories = ["safety", "career", "health", "rights", "tech", "world"] as const;
    const createdDebates = [];

    for (let slot = 1; slot <= 6; slot++) {
      const category = categories[slot - 1];
      const topics = debateTopics[category];
      const topicIndex = dayOfYear % topics.length;
      const topic = topics[topicIndex];

      const debateId = await ctx.db.insert("dailyDebates", {
        date: targetDate,
        slot,
        category,
        title: topic.title,
        summary: topic.summary,
        sourceUrl: "https://miaurora.app",
        sourceName: "Aurora App Community",
        agreeCount: 0,
        disagreeCount: 0,
        neutralCount: 0,
        commentCount: 0,
        isAutoGenerated: true,
        isActive: true,
      });

      createdDebates.push(debateId);
    }

    return { 
      success: true, 
      message: `Created ${createdDebates.length} debates for ${targetDate}`,
      count: createdDebates.length,
      debateIds: createdDebates,
    };
  },
});

/**
 * Delete all debates for a date (admin only)
 */
export const deleteDebatesForDate = mutation({
  args: { date: v.string() },
  handler: async (ctx, args) => {
    const debates = await ctx.db
      .query("dailyDebates")
      .withIndex("by_date", (q) => q.eq("date", args.date))
      .collect();
    
    for (const debate of debates) {
      await ctx.db.delete(debate._id);
    }

    return { success: true, deleted: debates.length };
  },
});


// ============================================
// ADMIN MONITORING & ANALYTICS
// ============================================

/**
 * Get debate analytics for admin dashboard
 */
export const getDebateAnalytics = query({
  args: { date: v.optional(v.string()) },
  handler: async (ctx, args) => {
    const targetDate = args.date || new Date().toISOString().split("T")[0];
    
    const debates = await ctx.db
      .query("dailyDebates")
      .withIndex("by_date", (q) => q.eq("date", targetDate))
      .collect();

    // Get all votes for these debates
    const debateIds = debates.map(d => d._id);
    const allVotes = await Promise.all(
      debateIds.map(async (debateId) => {
        const votes = await ctx.db
          .query("debateVotes")
          .withIndex("by_debate", (q) => q.eq("debateId", debateId))
          .collect();
        return { debateId, votes };
      })
    );

    // Get all comments for these debates
    const allComments = await Promise.all(
      debateIds.map(async (debateId) => {
        const comments = await ctx.db
          .query("debateComments")
          .withIndex("by_debate", (q) => q.eq("debateId", debateId))
          .collect();
        return { debateId, comments };
      })
    );

    // Calculate analytics
    const analytics = debates.map((debate) => {
      const debateVotes = allVotes.find(v => v.debateId === debate._id)?.votes || [];
      const debateComments = allComments.find(c => c.debateId === debate._id)?.comments || [];
      
      const memberVotes = debateVotes.filter(v => v.voterType === "member").length;
      const anonymousVotes = debateVotes.filter(v => v.voterType === "anonymous").length;
      const memberComments = debateComments.filter(c => c.authorType === "member").length;
      const anonymousComments = debateComments.filter(c => c.authorType === "anonymous").length;

      return {
        ...debate,
        totalVotes: debate.agreeCount + debate.disagreeCount + debate.neutralCount,
        memberVotes,
        anonymousVotes,
        memberComments,
        anonymousComments,
        engagementScore: (debate.agreeCount + debate.disagreeCount + debate.neutralCount) + (debate.commentCount * 2),
        conversionPotential: anonymousVotes + anonymousComments, // Users who could convert
      };
    });

    // Summary stats
    const totalVotes = analytics.reduce((sum, d) => sum + d.totalVotes, 0);
    const totalComments = analytics.reduce((sum, d) => sum + d.commentCount, 0);
    const totalMemberEngagement = analytics.reduce((sum, d) => sum + d.memberVotes + d.memberComments, 0);
    const totalAnonymousEngagement = analytics.reduce((sum, d) => sum + d.anonymousVotes + d.anonymousComments, 0);

    return {
      date: targetDate,
      debates: analytics.sort((a, b) => b.engagementScore - a.engagementScore),
      summary: {
        totalDebates: debates.length,
        totalVotes,
        totalComments,
        totalMemberEngagement,
        totalAnonymousEngagement,
        conversionOpportunity: totalAnonymousEngagement,
        avgEngagementPerDebate: debates.length > 0 ? Math.round((totalVotes + totalComments) / debates.length) : 0,
      },
    };
  },
});

/**
 * Get archived debates (historical data)
 */
export const getArchivedDebates = query({
  args: { 
    startDate: v.optional(v.string()),
    endDate: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const today = new Date().toISOString().split("T")[0];
    const endDate = args.endDate || today;
    const limit = args.limit || 30;

    // Get all debates, sorted by date descending
    let debates = await ctx.db
      .query("dailyDebates")
      .order("desc")
      .collect();

    // Filter by date range
    debates = debates.filter(d => {
      if (args.startDate && d.date < args.startDate) return false;
      if (d.date > endDate) return false;
      return true;
    });

    // Group by date
    const groupedByDate: Record<string, typeof debates> = {};
    for (const debate of debates.slice(0, limit * 6)) {
      if (!groupedByDate[debate.date]) {
        groupedByDate[debate.date] = [];
      }
      groupedByDate[debate.date].push(debate);
    }

    // Calculate daily stats
    const dailyStats = Object.entries(groupedByDate)
      .map(([date, dayDebates]) => ({
        date,
        debateCount: dayDebates.length,
        totalVotes: dayDebates.reduce((sum, d) => sum + d.agreeCount + d.disagreeCount + d.neutralCount, 0),
        totalComments: dayDebates.reduce((sum, d) => sum + d.commentCount, 0),
        topDebate: dayDebates.sort((a, b) => 
          (b.agreeCount + b.disagreeCount + b.neutralCount + b.commentCount) - 
          (a.agreeCount + a.disagreeCount + a.neutralCount + a.commentCount)
        )[0],
        debates: dayDebates.sort((a, b) => a.slot - b.slot),
      }))
      .sort((a, b) => b.date.localeCompare(a.date))
      .slice(0, limit);

    return {
      archives: dailyStats,
      totalDays: dailyStats.length,
      dateRange: {
        start: dailyStats[dailyStats.length - 1]?.date || today,
        end: dailyStats[0]?.date || today,
      },
    };
  },
});

/**
 * Get detailed debate with all votes and comments (for admin)
 */
export const getDebateDetails = query({
  args: { debateId: v.id("dailyDebates") },
  handler: async (ctx, args) => {
    const debate = await ctx.db.get(args.debateId);
    if (!debate) return null;

    // Get all votes with voter info
    const votes = await ctx.db
      .query("debateVotes")
      .withIndex("by_debate", (q) => q.eq("debateId", args.debateId))
      .collect();

    const enrichedVotes = await Promise.all(
      votes.map(async (vote) => {
        let voterInfo = { name: "Anonymous", flag: "ðŸŒ" };
        
        if (vote.voterType === "member" && vote.memberId) {
          const member = await ctx.db.get(vote.memberId);
          if (member) {
            voterInfo = { name: member.name, flag: "" };
          }
        } else if (vote.anonymousId) {
          const anon = await ctx.db.get(vote.anonymousId);
          if (anon) {
            voterInfo = { name: anon.pseudonym, flag: anon.countryFlag };
          }
        }

        return {
          ...vote,
          voterInfo,
          timestamp: vote.timestamp,
        };
      })
    );

    // Get all comments with author info
    const comments = await ctx.db
      .query("debateComments")
      .withIndex("by_debate", (q) => q.eq("debateId", args.debateId))
      .collect();

    const enrichedComments = await Promise.all(
      comments.map(async (comment) => {
        let authorInfo = { name: "Anonymous", flag: "ðŸŒ", badge: null as string | null };
        
        if (comment.authorType === "member" && comment.memberId) {
          const member = await ctx.db.get(comment.memberId);
          if (member) {
            authorInfo = { 
              name: member.name, 
              flag: "", 
              badge: member.isPremium ? "premium" : null 
            };
          }
        } else if (comment.anonymousId) {
          const anon = await ctx.db.get(comment.anonymousId);
          if (anon) {
            authorInfo = { name: anon.pseudonym, flag: anon.countryFlag, badge: null };
          }
        }

        return {
          ...comment,
          authorInfo,
        };
      })
    );

    return {
      debate,
      votes: enrichedVotes.sort((a, b) => b.timestamp - a.timestamp),
      comments: enrichedComments.sort((a, b) => (b._creationTime || 0) - (a._creationTime || 0)),
      stats: {
        totalVotes: votes.length,
        memberVotes: votes.filter(v => v.voterType === "member").length,
        anonymousVotes: votes.filter(v => v.voterType === "anonymous").length,
        totalComments: comments.length,
        memberComments: comments.filter(c => c.authorType === "member").length,
        anonymousComments: comments.filter(c => c.authorType === "anonymous").length,
      },
    };
  },
});

/**
 * Export debate data for archiving (admin only)
 */
export const exportDebateData = query({
  args: { date: v.string() },
  handler: async (ctx, args) => {
    const debates = await ctx.db
      .query("dailyDebates")
      .withIndex("by_date", (q) => q.eq("date", args.date))
      .collect();

    const fullData = await Promise.all(
      debates.map(async (debate) => {
        const votes = await ctx.db
          .query("debateVotes")
          .withIndex("by_debate", (q) => q.eq("debateId", debate._id))
          .collect();

        const comments = await ctx.db
          .query("debateComments")
          .withIndex("by_debate", (q) => q.eq("debateId", debate._id))
          .collect();

        return {
          debate,
          votes,
          comments,
        };
      })
    );

    return {
      date: args.date,
      exportedAt: new Date().toISOString(),
      data: fullData,
    };
  },
});
