/**
 * useLivestream Hook
 * 
 * React hook that wraps the StreamingProvider abstraction.
 * Provides a clean API for livestreaming without exposing provider details.
 */

import { useState, useEffect, useRef, useCallback } from 'react';
import { AgoraProvider } from '@/lib/agora-provider';
import { StreamingProvider, StreamingEvent, StreamStats } from '@/lib/streaming-provider';
import { useAction, useMutation } from 'convex/react';
import { api } from '@/convex/_generated/api';
import type { Id } from '@/convex/_generated/dataModel';

interface UseLivestreamOptions {
  channelName: string;
  userId: string;
  role: 'host' | 'audience';
  onError?: (error: Error) => void;
}

interface LivestreamState {
  isConnected: boolean;
  isStreaming: boolean;
  isCameraEnabled: boolean;
  isMicrophoneEnabled: boolean;
  viewerCount: number;
  stats: StreamStats | null;
  error: string | null;
}

export function useLivestream(options?: UseLivestreamOptions) {
  const [provider, setProvider] = useState<StreamingProvider | null>(null);
  const [state, setState] = useState<LivestreamState>({
    isConnected: false,
    isStreaming: false,
    isCameraEnabled: true,
    isMicrophoneEnabled: true,
    viewerCount: 0,
    stats: null,
    error: null,
  });

  const generateToken = useAction(api.actions.agora.generateAgoraToken);
  const localVideoRef = useRef<HTMLDivElement>(null);
  const remoteVideosRef = useRef<Map<string, HTMLDivElement>>(new Map());

  // Initialize provider
  const initialize = useCallback(async (opts: UseLivestreamOptions): Promise<StreamingProvider> => {
    try {
      setState(prev => ({ ...prev, error: null }));

      console.log('Getting Agora token for channel:', opts.channelName);

      // Get Agora token
      const tokenData = await generateToken({
        channelName: opts.channelName,
        userId: opts.userId,
        role: opts.role,
      });

      // Validate token data
      if (!tokenData.success || !tokenData.appId) {
        const errorMsg = tokenData.message || 'Agora App ID not configured. Livestreaming is not available.';
        throw new Error(errorMsg);
      }

      console.log('Agora token received:', { 
        mode: tokenData.mode, 
        uid: tokenData.uid,
        hasToken: !!tokenData.token,
        appId: tokenData.appId?.substring(0, 8) + '...'
      });

      // Create provider instance
      const newProvider = new AgoraProvider();

      // Set up event listeners
      newProvider.on(StreamingEvent.CONNECTED, () => {
        console.log('Agora: Connected');
        setState(prev => ({ ...prev, isConnected: true }));
      });

      newProvider.on(StreamingEvent.DISCONNECTED, () => {
        console.log('Agora: Disconnected');
        setState(prev => ({ ...prev, isConnected: false, isStreaming: false }));
      });

      newProvider.on(StreamingEvent.STREAM_STARTED, () => {
        console.log('Agora: Stream started');
        setState(prev => ({ ...prev, isStreaming: true }));
      });

      newProvider.on(StreamingEvent.STREAM_STOPPED, () => {
        console.log('Agora: Stream stopped');
        setState(prev => ({ ...prev, isStreaming: false }));
      });

      newProvider.on(StreamingEvent.STREAM_ERROR, (error: Error) => {
        console.error('Agora: Stream error', error);
        setState(prev => ({ ...prev, error: error.message }));
        opts.onError?.(error);
      });

      newProvider.on(StreamingEvent.USER_JOINED, () => {
        setState(prev => ({ ...prev, viewerCount: prev.viewerCount + 1 }));
      });

      newProvider.on(StreamingEvent.USER_LEFT, () => {
        setState(prev => ({ ...prev, viewerCount: Math.max(0, prev.viewerCount - 1) }));
      });

      newProvider.on(StreamingEvent.USER_PUBLISHED, (user: any, mediaType: string, track: any) => {
        if (mediaType === 'video' && track) {
          // Play remote video in container
          const container = document.getElementById(`remote-video-${user.uid}`);
          if (container) {
            (newProvider as AgoraProvider).playRemoteVideo(track, container);
          }
        }
      });

      console.log('Initializing Agora provider...');

      // Initialize provider with numeric UID from token generation
      await newProvider.initialize({
        channelName: opts.channelName,
        token: tokenData.token,
        appId: tokenData.appId!,
        uid: String(tokenData.uid), // Use the numeric UID generated by the server
      });

      console.log('Agora provider initialized successfully');

      // Update state and ref
      setProvider(newProvider);
      providerRef.current = newProvider;
      
      return newProvider;
    } catch (error) {
      const err = error as Error;
      console.error('Failed to initialize Agora:', err);
      setState(prev => ({ ...prev, error: err.message }));
      opts.onError?.(err);
      throw error;
    }
  }, [generateToken]);

  // Reference to provider for direct access
  const providerRef = useRef<StreamingProvider | null>(null);

  // Keep providerRef in sync with provider state
  useEffect(() => {
    providerRef.current = provider;
  }, [provider]);

  // Start broadcasting (host)
  const startBroadcast = useCallback(async (options?: {
    video?: boolean;
    audio?: boolean;
  }) => {
    if (!provider) throw new Error('Provider not initialized');

    try {
      await provider.startBroadcast(options);
      console.log('Broadcast started, local video track should be ready');
    } catch (error) {
      const err = error as Error;
      setState(prev => ({ ...prev, error: err.message }));
      throw error;
    }
  }, [provider]);

  // Play local video in a container element
  const playLocalVideo = useCallback((container: HTMLElement) => {
    const currentProvider = providerRef.current;
    if (!currentProvider) {
      console.warn('Provider not initialized, cannot play local video');
      return;
    }
    console.log('Playing local video in container:', container);
    (currentProvider as AgoraProvider).playLocalVideo(container);
  }, []);

  // Stop broadcasting
  const stopBroadcast = useCallback(async () => {
    if (!provider) return;

    try {
      await provider.stopBroadcast();
    } catch (error) {
      const err = error as Error;
      setState(prev => ({ ...prev, error: err.message }));
      throw error;
    }
  }, [provider]);

  // Join as viewer
  const joinAsViewer = useCallback(async () => {
    if (!provider) throw new Error('Provider not initialized');

    try {
      await provider.joinAsViewer();
    } catch (error) {
      const err = error as Error;
      setState(prev => ({ ...prev, error: err.message }));
      throw error;
    }
  }, [provider]);

  // Leave stream
  const leave = useCallback(async () => {
    if (!provider) return;

    try {
      await provider.leave();
    } catch (error) {
      const err = error as Error;
      setState(prev => ({ ...prev, error: err.message }));
      throw error;
    }
  }, [provider]);

  // Toggle camera
  const toggleCamera = useCallback(async () => {
    if (!provider) return;

    try {
      const newState = !state.isCameraEnabled;
      await provider.toggleCamera(newState);
      setState(prev => ({ ...prev, isCameraEnabled: newState }));
    } catch (error) {
      const err = error as Error;
      setState(prev => ({ ...prev, error: err.message }));
      throw error;
    }
  }, [provider, state.isCameraEnabled]);

  // Toggle microphone
  const toggleMicrophone = useCallback(async () => {
    if (!provider) return;

    try {
      const newState = !state.isMicrophoneEnabled;
      await provider.toggleMicrophone(newState);
      setState(prev => ({ ...prev, isMicrophoneEnabled: newState }));
    } catch (error) {
      const err = error as Error;
      setState(prev => ({ ...prev, error: err.message }));
      throw error;
    }
  }, [provider, state.isMicrophoneEnabled]);

  // Switch camera
  const switchCamera = useCallback(async () => {
    if (!provider) return;

    try {
      await provider.switchCamera();
    } catch (error) {
      const err = error as Error;
      setState(prev => ({ ...prev, error: err.message }));
      throw error;
    }
  }, [provider]);

  // Get devices
  const getDevices = useCallback(async () => {
    if (!provider) return { cameras: [], microphones: [] };
    return await provider.getDevices();
  }, [provider]);

  // Get stats
  const getStats = useCallback(async () => {
    if (!provider) return null;
    const stats = await provider.getStats();
    setState(prev => ({ ...prev, stats }));
    return stats;
  }, [provider]);

  // Set video quality
  const setVideoQuality = useCallback(async (quality: 'low' | 'medium' | 'high') => {
    if (!provider) return;
    await provider.setVideoQuality(quality);
  }, [provider]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (provider) {
        provider.destroy();
      }
    };
  }, [provider]);

  // Auto-initialize if options provided
  useEffect(() => {
    if (options && !provider) {
      initialize(options);
    }
  }, [options, provider, initialize]);

  return {
    // State
    ...state,
    provider,

    // Actions
    initialize,
    startBroadcast,
    stopBroadcast,
    joinAsViewer,
    leave,
    toggleCamera,
    toggleMicrophone,
    switchCamera,
    getDevices,
    getStats,
    setVideoQuality,
    playLocalVideo,

    // Refs for video containers
    localVideoRef,
    remoteVideosRef,
  };
}
